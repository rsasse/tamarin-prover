theory Signed_DH_with_reveal
begin

section{* The Signed Diffie-Hellman Protocol wiht key reveal *}

builtins: diffie-hellman, signing

// Public key infrastructure
rule Register_pk:
  let pubk = pk(~ltk)
  in
  [ Fr(~ltk) ] 
  --> 
  [ !Ltk($A, ~ltk), !Pk($A, pubk), Out(pubk) ]

rule Reveal_ltk:
    [ !Ltk(A, ltk) ]
  --[ LtkReveal(A) ]->
    [ Out(ltk) ]

// Protocol
rule Init_1:
  [ Fr(~ekI), !Ltk($I, ltkI) ]
  -->
  [ Init_1( $I, $R, ~ekI )
  , Out( <$I, $R, 'g' ^ ~ekI, sign{'1', $I, $R,'g' ^ ~ekI }ltkI> ) ]

rule Init_2:
    [ Init_1( $I, $R, ~ekI )
    , !Pk($R, pk(ltkR))
    , In( <$R, $I, Y, sign{'2', $R, $I, Y }ltkR> ) 
    ]
  --[ SessionKey($I,$R, Y ^ ~ekI) ]->
    []

rule Resp:
    [ !Pk($I, pk(ltkI))
    , !Ltk($R, ltkR)
    , Fr(~ekR)
    , In( <$I, $R, X, sign{'1', $I, $R, X }ltkI> ) 
    ]
  --[ SessionKey($I,$R, X ^ ~ekR) ]->
    [
      Out( <$R, $I, 'g' ^ ~ekR, sign{'2', $R, $I, 'g' ^ ~ekR }ltkR> ) 
    ]

// VIOLATED
lemma Key_Secret:
  "All I R sessKey #i. 
     SessionKey(I,R,sessKey) @ #i 
     ==> not (Ex #j. K(sessKey) @ #j)"


lemma Key_Secret_no_reveal:
  "All I R sessKey #i. 
     SessionKey(I,R,sessKey) @ #i 
     ==> not (Ex #j. K(sessKey) @ #j)
       |
         ( (Ex #r. LtkReveal(I) @ r)
         | (Ex #r. LtkReveal(R) @ r)
         )
"

//PROOF
lemma Key_Secret_PFS:
  "All I R sessKey #i. 
     SessionKey(I,R,sessKey) @ #i 
     ==> not (Ex #j. K(sessKey) @ #j)
       |
         ( (Ex #r. LtkReveal(I) @ r & r < i)
         | (Ex #r. LtkReveal(R) @ r & r < i)
         )
"

lemma executable:
  exists-trace
  "Ex I R sessKey #i #j. SessionKey(I,R,sessKey)@ #i & SessionKey(I,R,sessKey)@ #j & not (#i = #j)"

end
